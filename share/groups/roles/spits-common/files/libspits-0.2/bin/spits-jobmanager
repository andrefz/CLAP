#!/bin/bash
# set -x
SPITS_JOB_DIR="${SPITS_JOB_DIR:-$HOME/spits-jobs}"
SCRIPTSDIR="$( cd "$(dirname "$0")"; pwd -P )"
JM_PATH="$SCRIPTSDIR/../jm.py"

abort() {
    echo -e $1
    exit 1
}

usage() {
    echo "Usage: $0 [-f|--force] <jobid> [additional_jm_args]"
    exit 1
}

# Check SPITS files...
if [ ! -f $JM_PATH ]; then
    abort "Invalid task manager file at: $JM_PATH"
fi

# Check the number of arguments
if [ "$#" -lt 1 ]; then usage; fi

# Check each argument
for arg in "$@"; do
    if [[ "$arg" =~ ^\-+.*$ ]]; then
        case $1 in
            -f|--force) FORCE=1 ;;
            *) echo "Invalid argument: $1"; ERROR=1 ;;
        esac
        shift
    else
        break;
    fi
done
# Any error in arguments?
if [ ! -z "$ERROR" ]; then usage; fi

# Set job information
JOBID=$1
JM_ARGS=${@: 2}

# Check SPITS job directory files...
if [ ! -f "$SPITS_JOB_DIR/$JOBID/job" ]; then
    abort "Invalid job repository (without job file) for job $JOBID"
fi

# Check if the job has already finished...
if [ ! -f "$SPITS_JOB_DIR/$JOBID/finished" ]; then
    abort "Invalid job repository (without finished file) for job $JOBID"
fi

# Check if a job manager already exists
if [ -f "$SPITS_JOB_DIR/$JOBID/jm.exists" ]; then
    # Not --force option? Abort
    if [ -z "$FORCE" ]; then
        abort "A job manager already exists for job \`$JOBID\` (jm.exists file)!"
    fi
fi

# Get job command
JOBCOMMAND=$(head -n 1 "$SPITS_JOB_DIR/$JOBID/job")
# Make unique SPITS abbress
ADDR=$(hostname)
SPITS_UID="JM-$ADDR-$$"
SPITS_OUTPUT="logs/$SPITS_UID.out"
SPITS_ERR="logs/$SPITS_UID.err"
# Craft python commands and task manager arguments
PYTHON="${PYTHON:-$(which python3)}"
PYTHON_CMD+="$PYTHON -u"
JM_ARGS+=" --uid=$SPITS_UID --jobid=$JOBID --log=$SPITS_ERR --killtms --announce=file --verbose"
# Final Command to run
COMMAND="$PYTHON_CMD $JM_PATH $JM_ARGS $JOBCOMMAND"

# Write in status files..
echo "0" > "$SPITS_JOB_DIR/$JOBID/finished" || abort "Error starting jobmanager or job \`$JOBID\`"
echo "1" > "$SPITS_JOB_DIR/$JOBID/jm.exists" || abort "Error starting jobmanager or job \`$JOBID\`"

# Information....
echo "Using $SPITS_UID as UID"
echo "Using $SPITS_OUTPUT as default output"
echo "Using $SPITS_ERR as error output"
echo -e "Starting JobManager for job \`$JOBID\` with command:\n$COMMAND"

# Prepare to run the command
# Set signal handler for the command
signal_handler() {
    # Get the trap result...
    RES=$?
    echo "Caught signal! Killing childs..."
    kill -9 "$child" 2>/dev/null
    rm -f "$SPITS_JOB_DIR/$JOBID/jm.exists"
    rm -f "$SPITS_JOB_DIR/$JOBID/nodes/$SPITS_UID"
}
# Trap signals: SIGTERM SIGKILL SIGINT to signal_handler function
trap signal_handler SIGTERM SIGKILL SIGINT

# Enter JOB PATH
cd "$SPITS_JOB_DIR/$JOBID/"
# Run command! In background..
echo -e "Starting JobManager for job \`$JOBID\` with command:\n$COMMAND > $SPITS_OUTPUT &"
$COMMAND > $SPITS_OUTPUT &
# Get process PID and wait, or catch
child=$!
wait "$child"
# Get result
RES=$?

# Finishing routine...
echo "Jobmanager terminated with status: $RES"

# Remove existence file...
rm -f "$SPITS_JOB_DIR/$JOBID/jm.exists"
rm -f "$SPITS_JOB_DIR/$JOBID/nodes/$SPITS_UID"

# Finished with code 0. Finihed job!
if [ $((RES)) == 0 ]; then
    echo "1" > "$SPITS_JOB_DIR/$JOBID/finished"
    echo "Job \`$JOBID\` finished!"
fi

# FINISH!
exit $RES
