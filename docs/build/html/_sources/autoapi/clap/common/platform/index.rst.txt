:mod:`clap.common.platform`
===========================

.. py:module:: clap.common.platform


Module Contents
---------------


.. py:class:: ModuleInterface(module_paths: List[str] = None, force=False)

   Interface to get clap modules from the modules repositories
       

   .. attribute:: __modules_map__
      

      

   .. method:: __check_dependencies__()
      :staticmethod:



   .. method:: __find_modules__(module_paths: List[str] = None, force: bool = False)
      :staticmethod:


      Find CLAP modules located at CLAP search paths

      :param module_paths: List of pathsto search CLAP modules
      :type module_paths: List[str]
      :param force: Search even if it is already searched once
      :type force: bool


   .. method:: get_module(self, module_name: str)


      Get the module package

      :param module_name: Name of the clap's module (as python module)
      :type module_name: str
      :return: The module
      :rtype: Module


   .. method:: get_modules(self)


      Get the module package

      :return: Dictionaty with modules information. Theinformation are:
        - name: Name of the module
        - description: Module's description
        - dependencies: Module's depencencies
        - module: The loaded module (as python module)
        - loaded_time: Date when the module was loaded
      :rtype: Dict[str, Any]


   .. method:: get_module_names(self)


      Get the name of all the modules in the clap modules repository

      :return: List containing the all module names
      :rtype: List[str]



.. py:class:: GroupInterface

   This interface collects and maintains information about groups in the CLAP system
       

   .. attribute:: __groups_actions_map__
      

      

   .. method:: __find_groups(force: bool = False)
      :staticmethod:


      Find CLAP groups at group's path

      :param force: Force to research groups, even if it is already searched once
      :type force: bool


   .. method:: get_group(self, group_name: str)


      Get group based on the group name

      :param group_name: Name of the group to get
      :type group_name: str
      :return: Dictionary with group's information. The dictionary contains the following keys:
          * name: Group's name
          * actions: List of group's actions
          * hosts: List of group's hosts
          * dependecies: List of group's dependencies
      :rtype: Dict[str, Any]


   .. method:: get_group_names(self)


      Get name of all groups in CLAP's system 

      :return: List of group's names
      :rtype: List[str]



.. py:class:: MultiInstanceAPI(platform_db: str, repository_type: str, default_driver: str)

   API used to manage and perform operations in nodes from different driver implementations,
   and cloud providers in a transparently manner.

   .. attribute:: __interfaces_map__
      

      

   .. method:: __find_ifaces()
      :staticmethod:



   .. method:: _get_instance_iface(self, driver_id: str = None)



   .. method:: get_instance_templates()
      :staticmethod:


      Get the instance templates defined in the instance configuration files.

      :return:    Dictionary with instance templates. The keys are the instance name and the value are the values for the instance. 
                  The dictionary have the same values for the instance configuration files
      :rtype: Dict[str, Any]


   .. method:: start_nodes(self, instances_num: Dict[str, int])


      Start instances based on the configuration values

      :param instances_num: Dictionary containing the instance name as key and number of instances as value. The instance name must match the instance name at instances configuration file
      :type instances_num: Dict[str, int]
      :return: A list of created nodes 
      :rtype: List[NodeInfo]


   .. method:: stop_nodes(self, node_ids: List[str], force: bool = True)


      Stop started nodes based on their node ids

      :param node_ids: List of node ids to stop
      :type node_ids: List[str]
      :return: A list of stopped nodes 
      :rtype: List[str]


   .. method:: pause_nodes(self, node_ids: List[str])


      Pause started nodes based on their node ids

      :param node_ids: List of node ids to pause
      :type node_ids: List[str]
      :return: A list of paused nodes 
      :rtype: List[str]


   .. method:: resume_nodes(self, node_ids: List[str])


      Resume paused nodes based on their node ids

      :param node_ids: List of node ids to resume
      :type node_ids: List[str]
      :return: A list of resumed nodes 
      :rtype: List[str]


   .. method:: check_nodes_alive(self, node_ids: List[str])


      Check if nodes are alive, based on their node ids. The nodes are alive if a successfully SSH connection is performed

      :param node_ids: List of node ids to check for aliveness.
      :type node_ids: List[str]
      :return: A dictionary telling which nodes are alive. The dictionary keys correspond to the node id and the value is a boolean that is true if node is alive or false otherwise. 
      :rtype: Dict[str, bool]


   .. method:: execute_playbook_in_nodes(self, playbook_path: str, hosts: Union[List[str], Dict[str, List[str]]], extra_args: Dict[str, str] = None)


      Execute an Ansible Playbook at nodes based on their node ids.

      :param playbook_path: Path of the Ansible playbook to execute.
      :type playbook_path: str
      :param hosts: Nodes which playbooks will be executed. The variables can be, one of them:
        - A List of node ids, telling which nodes the playbook will be executed
        - A Dictionary telling the ansible host name (as key) and a list of node ids as value. The ansible inventory will be generated putting each node list inside the respective host.
      :type hosts: Union[List[str], Dict[str, List[str]]]
      :param extra_args: Key-valued dictionary containing the extra variables to be passed to the playbook. Both key and value are strings
      :type extra_args: Dict[str, str]
      :return: A dictionary telling which nodes have sucessfully executed the playbook. The dictionary keys correspond to the node id and the value is a boolean that is true if node successfully executed the playbook or false otherwise. 
      :rtype: Dict[str, bool]


   .. method:: get_connection_to_nodes(self, node_ids: List[str], *args, **kwargs)


      Get a SSH client to nodes.

      :param node_ids: List of node ids to get the clients.
      :type node_ids: List[str]
      :return: A dictionary with the SSH clients. The key is the node id and each value is the SSH client (from Paramiko library)
      :rtype: Dict[str, Paramiko.SSHClient]


   .. method:: get_nodes(self, node_ids: List[str])


      Get the information of nodes from the node repository

      :param node_ids: List of node ids to get the node information.
      :type node_ids: List[str]
      :return: A list with nodes information 
      :rtype: List[NodeInfo]


   .. method:: get_all_nodes(self)


      Get all nodes information from the repository

      :return: A list with nodes information 
      :rtype: List[NodeInfo]


   .. method:: get_nodes_with_tags(self, tags: Dict[str, str])


      Get the information of nodes from the node repository that match the tags informed

      :param tags: Key-valued dictionary with informing tags to be searched in nodes. A matched node is a node which contains the tags and the tag value match the informed tags value. The node must match all tags passed.
      :type tags: Dict[str, str]
      :return: A list with nodes information 
      :rtype: List[NodeInfo]


   .. method:: add_tags_to_nodes(self, node_ids: List[str], tags: Dict[str, str])


      Add tags to nodes

      :param node_ids: List of node ids to add the tags.
      :type node_ids: List[str]
      :param tags: Key-valued dictionary with informing the tags key and value. Each tag may contain a set of value, so if a value a tag with the same key already exists in node, the value will be added to the tag set.
      :type tags: Dict[str, str]
      :return: A list of nodes which the tags were added 
      :rtype: List[str]


   .. method:: remove_tags_from_nodes(self, node_ids: List[str], tags: Dict[str, str])


      Remove a tag value from a node tag set 

      :param node_ids: List of node ids to remove the tags.
      :type node_ids: List[str]
      :param tags: Key-valued dictionary with informing the tags key and value. The value will be removed from each tag set. If the tag set contains no value, the node tag will be removed.
      :type tags: Dict[str, str]
      :return: A list of nodes which the tags were removed 
      :rtype: List[str]


   .. method:: remove_tags_from_nodes_by_key(self, node_ids: List[str], tags: List[str])


      Remove all values from a tag set from nodes

      :param node_ids: List of node ids to remove the tags.
      :type node_ids: List[str]
      :param tags: List of tags to remove from nodes (all tag values will be removed from the tag set of the node)
      :type tags: List[str]
      :return: A list of nodes which the tags were removed 
      :rtype: List[str]


   .. method:: get_groups(self)


      Get all CLAP groups

      :return: A List of dictionary with groups information. Each dictionary's element of the list contains:
        - name: The group's name (string)
        - actions: The list of group's actions (list of string)
        - hosts: The list group's host (list of string)
      :rtype: List[Dict[str, Any]]


   .. method:: __execute_group_action__(self, hosts: Dict[str, List[str]], action_dict: str, action_name: str, extra_args: Dict[str, str])



   .. method:: __get_nodes_in_group__(self, group: str, node_ids: List[str] = None)



   .. method:: __check_nodes_in_group__(self, group_name: str, node_ids: List[str] = None)



   .. method:: add_nodes_to_group(self, node_ids: List[str], group_name: str, group_args: Dict[str, str] = None, __processing_dependencies__: List[str] = None)


      Add nodes to a informed group

      :param node_ids: List of node ids to add the the group.
      :type node_ids: List[str]
      :param group_name: Name of the group which the nodes will be added. If the group has a setup action, the setup action will be executed.
      :type group_name: str
      :param group_args: Key-valued dictionary with the extra arguments to be passed to the setup's action.
      :type group_args: Dict[str, str]
      :param __processing_dependencies__: Internal parameter used to check ciclycal dependencies
      :type __processing_dependencies__: List[str]
      :return: A list of nodes that was successfully added to group. A node is sucessfully added to the group if the setup action was sucessfully performed (if any)
      :rtype: List[str] 


   .. method:: __add_nodes_to_group(self, group_hosts_map: Dict[str, Union[List[str], Dict[str, List[str]]]], group_args: Dict = None)



   .. method:: execute_group_action(self, group_name: str, action: str, group_args: Dict = None, node_ids: List[str] = None)


      Perform a group action in all nodes belonging to a group

      :param group_name: Name of the group which the action will be performed
      :type group_name: str
      :param action: Name of the group's action to be perfomed
      :type action: str 
      :param group_args: Key-valued dictionary with the extra arguments to be passed to the action.
      :type group_args: Dict[str, str]
      :param node_ids: List of node ids which the action will be performed. If None is informed, the action will be performed to all nodes belonging to the group informed. 
      :type node_ids: List[str]
      :return: A list of nodes that successfully performed the action.
      :rtype: List[str] 


   .. method:: __execute_group_action(self, node_ids: List[str], group_name: str, action: str, group_args: Dict = None)



   .. method:: remove_nodes_from_group(self, group_name: str, node_ids: List[str] = None, remove_action: str = None, group_args: Dict = None)




