:mod:`clap.modules.cluster`
===========================

.. py:module:: clap.modules.cluster


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   commands/index.rst
   conf/index.rst
   module/index.rst
   repository/index.rst


Package Contents
----------------


.. py:class:: AbstractParser

   .. method:: add_parser(self, commands_parser: argparse._SubParsersAction)
      :abstractmethod:




.. data:: log
   

   

.. function:: path_extend(*args) -> str


.. function:: float_time_to_string(timespec: float)


.. py:class:: ClusterDefaults

   .. attribute:: CLUSTER_REPOSITORY_DIR
      

      

   .. attribute:: CLUSTER_SEARCH_PATH
      

      

   .. attribute:: CLUSTER_DEFAULT_FLETYPES
      :annotation: = ['yaml', 'yml']

      


.. function:: __is_valid_file__(fpath)


.. function:: __is_valid_directory__(fpath)


.. py:class:: ClusterParser

   Bases: :class:`clap.common.module.AbstractParser`

   .. method:: add_parser(self, commands_parser: argparse._SubParsersAction)



   .. method:: command_start_cluster(self, namespace: argparse.Namespace)



   .. method:: command_setup_cluster(self, namespace: argparse.Namespace)



   .. method:: command_add_more_nodes(self, namespace: argparse.Namespace)



   .. method:: command_existing_nodes(self, namespace: argparse.Namespace)



   .. method:: command_list_clusters(self, namespace: argparse.Namespace)



   .. method:: command_stop_cluster(self, namespace: argparse.Namespace)



   .. method:: command_alive_cluster_nodes(self, namespace: argparse.Namespace)



   .. method:: command_resume_cluster(self, namespace: argparse.Namespace)



   .. method:: command_pause_cluster(self, namespace: argparse.Namespace)



   .. method:: commands_list_templates(self, namespace: argparse.Namespace)



   .. method:: commands_update_cluster(self, namespace: argparse.Namespace)



   .. method:: commands_group_add(self, namespace: argparse.Namespace)



   .. method:: commands_group_action(self, namespace: argparse.Namespace)



   .. method:: commands_connect(self, namespace: argparse.Namespace)



   .. method:: commands_execute(self, namespace: argparse.Namespace)



   .. method:: commands_playbook(self, namespace: argparse.Namespace)



   .. method:: commands_copy(self, namespace: argparse.Namespace)



   .. method:: commands_fetch(self, namespace: argparse.Namespace)




.. py:class:: PlatformFactory

   .. attribute:: __multi_instance_api__
      

      

   .. attribute:: __module_iface__
      

      

   .. method:: get_module_interface()
      :staticmethod:


      Get the default ModuleInterface used to pick clap modules

      :return: The modules interface
      :rtype: ModuleInterface


   .. method:: get_instance_api(platform_db: str = Defaults.PLATFORM_REPOSITORY, repository_type: str = Defaults.REPOSITORY_TYPE, default_driver: str = Defaults.DRIVER_ID)
      :staticmethod:


      Get the default MultiInstance API used to manipulate cluster, nodes and modules across different drivers

      :return: The MultiInstanceAPI object to manipulate cluster, nodes and modules
      :rtype: MultiInstanceAPI



.. py:class:: NodeInfo(**kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`

   This class holds information about a node that is stored in the repository and used by several interfaces
   Each node is unique and is composed by the following elements:
       * node_id: The unique identification of the node, used to perform operations across modules and instance interfaces
       * node_name: The name of the node used by the driver object that controls it
       * cluster_id: ID of the cluster that this node is attached to
       * flavor: Instance flavor (e.g., t2.micro in aws)
       * status: Last known status of the node (see PlatformCodes)
       * ip: IP address used to connect to this node (address used to perform SSH)
       * driver_id: ID of the driver that controls this node
       * driver_version: Version of the driver used by this node
       * keypair: The name of the keypair used to connect to the machines created in the node cluster
       * key: The private key file used to perform SSH and connect to machines
       * tags: Additional user tags for node identification

   .. method:: __repr__(self)




.. py:class:: Codes

   Status codes for nodes
       

   .. attribute:: NODE_STATUS_INIT
      :annotation: = started

      

   .. attribute:: NODE_STATUS_UNREACHABLE
      :annotation: = unreachable

      

   .. attribute:: NODE_STATUS_REACHABLE
      :annotation: = reachable

      

   .. attribute:: NODE_STATUS_PAUSED
      :annotation: = paused

      

   .. attribute:: NODE_STATUS_STOPPED
      :annotation: = stopped

      


.. function:: yaml_load(filename: str) -> dict


.. function:: tmpdir(suffix=None, prefix='clap.', dir=None)


.. py:class:: ClusterData(**kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`


.. py:class:: ClusterRepositoryOperations(repository_name: str = 'cluster.json', repository_type: str = Defaults.REPOSITORY_TYPE, cluster_prefix='cluster')

   .. method:: exists_platform_db(self)



   .. method:: create_repository(self, exists: str = 'pass')



   .. method:: new_cluster(self, cluster_name, cluster_config, state: str = 'running')



   .. method:: get_cluster(self, cluster_id: str)



   .. method:: get_all_clusters(self)



   .. method:: update_cluster(self, cluster_data: ClusterData)



   .. method:: remove_cluster(self, cluster_id)




.. py:exception:: ConfigurationError

   Bases: :class:`Exception`


.. py:class:: ClusterState

   .. attribute:: CLUSTER_RUNNING
      :annotation: = running

      

   .. attribute:: CLUSTER_PAUSED
      :annotation: = paused

      


.. function:: __get_setups__(config_dict: dict) -> dict


.. function:: __get_clusters__(config_dict: dict) -> dict


.. function:: __validate_cluster_setups__(cluster_name: str, cluster_dict: dict, setups: dict) -> dict


.. function:: __perform_replacements__(config, extra_args: Dict[str, str])


.. function:: __validate_nodes__(cluster_name: str, cluster_data: dict, valid_instances: List[str]) -> dict


.. function:: __validate_groups_and_actions__(cluster_name: str, cluster_data: dict, valid_groups: Dict[str, List[str]]) -> dict


.. function:: __add_nodes_to_cluster__(cluster: ClusterData, node_types: Dict[str, Tuple[int, int]]) -> Dict[str, List[str]]


.. function:: __add_to_group__(setup_name: str, group: dict, node_ids: List[str], tags: Dict[str, str] = None, re_add_to_group: bool = False) -> List[str]


.. function:: __execute_action__(setup_name: str, action: dict, node_ids: List[str] = None, tags: Dict[str, str] = None)


.. function:: __run_setup__(cluster_name: str, setup_name: str, setup_dict: dict, node_ids: List[str] = None, tags: Dict[str, str] = None, re_add_to_group: bool = False)


.. function:: __run_setup_list__(cluster_name: str, setup_list: List[Dict[str, Any]], node_ids: List[str], re_add_to_group: bool)


.. function:: __get_nodes_from_cluster__(cluster_id: str, node_ids: List[str]) -> Tuple[List[str], List[str]]


.. function:: get_cluster_config(cluster_files: List[str], cluster_name: str, extra_args: Dict[str, str] = None)


.. function:: cluster_create(cluster_files: List[str], cluster_name: str, extra_args: Dict[str, str] = None, no_setup: bool = False) -> Tuple[ClusterData, List[NodeInfo], bool]


.. function:: add_nodes_to_cluster(cluster_id: str, node_types: Dict[str, int] = None, no_setup: bool = False, re_add_to_group: bool = False, at: str = 'before_all') -> Tuple[ClusterData, List[NodeInfo]]


.. function:: add_existing_nodes_to_cluster(cluster_id: str, node_types: Dict[str, List[str]], no_setup: bool = False, re_add_to_group: bool = False, at: str = 'before_all')


.. function:: cluster_setup(cluster_id: str, nodes_type: Dict[str, List[str]] = None, re_add_to_group: bool = False, at: str = 'before_all')


.. function:: cluster_setup_in_specific_nodes(cluster_id: str, node_ids: List[str] = None, re_add_to_group: bool = False, at: str = 'before_all')


.. function:: update_cluster_config(cluster_files: List[str], cluster_id: str, extra_args: Dict[str, str] = None) -> ClusterData


.. function:: cluster_stop(cluster_id: str, do_not_stop: bool = False) -> Tuple[List[str], List[str]]


.. function:: cluster_alive(cluster_id: str) -> Dict[str, bool]


.. function:: cluster_pause(cluster_id: str) -> Tuple[List[str], List[str]]


.. function:: cluster_resume(cluster_id: str, setup: bool = False, at='before_all') -> List[str]


.. function:: list_clusters(cluster_id: str = None) -> dict


.. function:: list_templates(cluster_files: List[str]) -> Tuple[dict, dict]


.. function:: cluster_group_add(cluster_id: str, group_name: str, node_ids: List[str] = None, re_add_to_group: bool = False, extra_args: Dict[str, str] = None) -> List[str]


.. function:: perform_group_action(cluster_id: str, group_name: str, action_name: str, node_ids: List[str] = None, extra_args: Dict[str, str] = None) -> List[str]


.. function:: execute_playbook(cluster_id: str, playbook_path: str, node_ids: List[str] = None, extra_args: Dict[str, str] = None) -> Dict[str, bool]


.. function:: execute_command(cluster_id: str, command: str, node_ids: List[str] = None) -> Dict[str, bool]


.. function:: cluster_copy_files(cluster_id: str, copy_from: str, copy_to: str, node_ids: List[str] = None)


.. function:: cluster_fetch_files(cluster_id: str, copy_from: str, copy_to: str, node_ids: List[str] = None)


.. function:: cluster_connect(cluster_id: str, node_id: str = None)


.. function:: run_playbook_in_nodes(playbook_path: str, node_ids: List[str], extra_args: Dict[str, str]) -> Dict[str, bool]


.. function:: run_command(node_ids: List[str], command_string: str)


.. function:: connect_to_node(node_id: str)


.. py:class:: PlatformFactory

   .. attribute:: __multi_instance_api__
      

      

   .. attribute:: __module_iface__
      

      

   .. method:: get_module_interface()
      :staticmethod:


      Get the default ModuleInterface used to pick clap modules

      :return: The modules interface
      :rtype: ModuleInterface


   .. method:: get_instance_api(platform_db: str = Defaults.PLATFORM_REPOSITORY, repository_type: str = Defaults.REPOSITORY_TYPE, default_driver: str = Defaults.DRIVER_ID)
      :staticmethod:


      Get the default MultiInstance API used to manipulate cluster, nodes and modules across different drivers

      :return: The MultiInstanceAPI object to manipulate cluster, nodes and modules
      :rtype: MultiInstanceAPI



.. py:class:: NodeInfo(**kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`

   This class holds information about a node that is stored in the repository and used by several interfaces
   Each node is unique and is composed by the following elements:
       * node_id: The unique identification of the node, used to perform operations across modules and instance interfaces
       * node_name: The name of the node used by the driver object that controls it
       * cluster_id: ID of the cluster that this node is attached to
       * flavor: Instance flavor (e.g., t2.micro in aws)
       * status: Last known status of the node (see PlatformCodes)
       * ip: IP address used to connect to this node (address used to perform SSH)
       * driver_id: ID of the driver that controls this node
       * driver_version: Version of the driver used by this node
       * keypair: The name of the keypair used to connect to the machines created in the node cluster
       * key: The private key file used to perform SSH and connect to machines
       * tags: Additional user tags for node identification

   .. method:: __repr__(self)




.. py:class:: Codes

   Status codes for nodes
       

   .. attribute:: NODE_STATUS_INIT
      :annotation: = started

      

   .. attribute:: NODE_STATUS_UNREACHABLE
      :annotation: = unreachable

      

   .. attribute:: NODE_STATUS_REACHABLE
      :annotation: = reachable

      

   .. attribute:: NODE_STATUS_PAUSED
      :annotation: = paused

      

   .. attribute:: NODE_STATUS_STOPPED
      :annotation: = stopped

      


.. data:: log
   

   

.. function:: yaml_load(filename: str) -> dict


.. function:: tmpdir(suffix=None, prefix='clap.', dir=None)


.. function:: path_extend(*args) -> str


.. py:class:: ClusterData(**kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`


.. py:class:: ClusterRepositoryOperations(repository_name: str = 'cluster.json', repository_type: str = Defaults.REPOSITORY_TYPE, cluster_prefix='cluster')

   .. method:: exists_platform_db(self)



   .. method:: create_repository(self, exists: str = 'pass')



   .. method:: new_cluster(self, cluster_name, cluster_config, state: str = 'running')



   .. method:: get_cluster(self, cluster_id: str)



   .. method:: get_all_clusters(self)



   .. method:: update_cluster(self, cluster_data: ClusterData)



   .. method:: remove_cluster(self, cluster_id)




.. py:class:: ClusterDefaults

   .. attribute:: CLUSTER_REPOSITORY_DIR
      

      

   .. attribute:: CLUSTER_SEARCH_PATH
      

      

   .. attribute:: CLUSTER_DEFAULT_FLETYPES
      :annotation: = ['yaml', 'yml']

      


.. py:exception:: ConfigurationError

   Bases: :class:`Exception`


.. py:class:: ClusterState

   .. attribute:: CLUSTER_RUNNING
      :annotation: = running

      

   .. attribute:: CLUSTER_PAUSED
      :annotation: = paused

      


.. function:: __get_setups__(config_dict: dict) -> dict


.. function:: __get_clusters__(config_dict: dict) -> dict


.. function:: __validate_cluster_setups__(cluster_name: str, cluster_dict: dict, setups: dict) -> dict


.. function:: __perform_replacements__(config, extra_args: Dict[str, str])


.. function:: __validate_nodes__(cluster_name: str, cluster_data: dict, valid_instances: List[str]) -> dict


.. function:: __validate_groups_and_actions__(cluster_name: str, cluster_data: dict, valid_groups: Dict[str, List[str]]) -> dict


.. function:: __add_nodes_to_cluster__(cluster: ClusterData, node_types: Dict[str, Tuple[int, int]]) -> Dict[str, List[str]]


.. function:: __add_to_group__(setup_name: str, group: dict, node_ids: List[str], tags: Dict[str, str] = None, re_add_to_group: bool = False) -> List[str]


.. function:: __execute_action__(setup_name: str, action: dict, node_ids: List[str] = None, tags: Dict[str, str] = None)


.. function:: __run_setup__(cluster_name: str, setup_name: str, setup_dict: dict, node_ids: List[str] = None, tags: Dict[str, str] = None, re_add_to_group: bool = False)


.. function:: __run_setup_list__(cluster_name: str, setup_list: List[Dict[str, Any]], node_ids: List[str], re_add_to_group: bool)


.. function:: __get_nodes_from_cluster__(cluster_id: str, node_ids: List[str]) -> Tuple[List[str], List[str]]


.. function:: get_cluster_config(cluster_files: List[str], cluster_name: str, extra_args: Dict[str, str] = None)


.. function:: cluster_create(cluster_files: List[str], cluster_name: str, extra_args: Dict[str, str] = None, no_setup: bool = False) -> Tuple[ClusterData, List[NodeInfo], bool]


.. function:: add_nodes_to_cluster(cluster_id: str, node_types: Dict[str, int] = None, no_setup: bool = False, re_add_to_group: bool = False, at: str = 'before_all') -> Tuple[ClusterData, List[NodeInfo]]


.. function:: add_existing_nodes_to_cluster(cluster_id: str, node_types: Dict[str, List[str]], no_setup: bool = False, re_add_to_group: bool = False, at: str = 'before_all')


.. function:: cluster_setup(cluster_id: str, nodes_type: Dict[str, List[str]] = None, re_add_to_group: bool = False, at: str = 'before_all')


.. function:: cluster_setup_in_specific_nodes(cluster_id: str, node_ids: List[str] = None, re_add_to_group: bool = False, at: str = 'before_all')


.. function:: update_cluster_config(cluster_files: List[str], cluster_id: str, extra_args: Dict[str, str] = None) -> ClusterData


.. function:: cluster_stop(cluster_id: str, do_not_stop: bool = False) -> Tuple[List[str], List[str]]


.. function:: cluster_alive(cluster_id: str) -> Dict[str, bool]


.. function:: cluster_pause(cluster_id: str) -> Tuple[List[str], List[str]]


.. function:: cluster_resume(cluster_id: str, setup: bool = False, at='before_all') -> List[str]


.. function:: list_clusters(cluster_id: str = None) -> dict


.. function:: list_templates(cluster_files: List[str]) -> Tuple[dict, dict]


.. function:: cluster_group_add(cluster_id: str, group_name: str, node_ids: List[str] = None, re_add_to_group: bool = False, extra_args: Dict[str, str] = None) -> List[str]


.. function:: perform_group_action(cluster_id: str, group_name: str, action_name: str, node_ids: List[str] = None, extra_args: Dict[str, str] = None) -> List[str]


.. function:: execute_playbook(cluster_id: str, playbook_path: str, node_ids: List[str] = None, extra_args: Dict[str, str] = None) -> Dict[str, bool]


.. function:: execute_command(cluster_id: str, command: str, node_ids: List[str] = None) -> Dict[str, bool]


.. function:: cluster_copy_files(cluster_id: str, copy_from: str, copy_to: str, node_ids: List[str] = None)


.. function:: cluster_fetch_files(cluster_id: str, copy_from: str, copy_to: str, node_ids: List[str] = None)


.. function:: cluster_connect(cluster_id: str, node_id: str = None)


.. function:: run_playbook_in_nodes(playbook_path: str, node_ids: List[str], extra_args: Dict[str, str]) -> Dict[str, bool]


.. function:: run_command(node_ids: List[str], command_string: str)


.. function:: connect_to_node(node_id: str)


.. py:class:: Defaults

   .. attribute:: verbosity
      :annotation: = 0

      

   .. attribute:: log_level
      

      

   .. attribute:: app_name
      :annotation: = clap

      

   .. attribute:: REPOSITORY_TYPE
      :annotation: = tinydb

      

   .. attribute:: DRIVER_ID
      :annotation: = ansible

      

   .. attribute:: DEFAULT_CONF_TYPE
      :annotation: = json

      

   .. attribute:: configs_path
      

      

   .. attribute:: private_path
      

      

   .. attribute:: storage_path
      

      

   .. attribute:: groups_path
      

      

   .. attribute:: actions_path
      

      

   .. attribute:: modules_path
      

      

   .. attribute:: modules_data
      

      

   .. attribute:: elasticluster_storage_path
      

      

   .. attribute:: cloud_conf
      

      

   .. attribute:: login_conf
      

      

   .. attribute:: instances_conf
      

      

   .. attribute:: PLATFORM_REPOSITORY
      

      


.. py:class:: AbstractEntry(*args, **kwargs)

   Bases: :class:`clap.common.utils.Struct`

   This class represent a single entry in the Repository. Basically its a dictionary that is a serializable and
   is a generic container for a data format. Implementations derived from this class represent specific element types in a repository.
   Objects (variables) inside this class can be accessed using `element['variable']` or `element.variable` notations


.. py:class:: AbstractRepository(repository: str, create_repository: bool, storage_type: str = None, *args, **kwargs)

   Base class for implementing repositories and their operations. The repository is similar to tabled data models.
   The elements are every object inherited from ``AbstractEntry`` class, which are basically, dictionary types.
   Tables hold a set of elements of the same type and must be created before adding elements.
   The repository then, implement a set of methods to create, retrieve, update and delete elements and tables from the database.

   .. attribute:: __repository_id__
      :annotation: = abstractrepository

      

   .. attribute:: __repository_name__
      :annotation: = Abstract Repository

      

   .. attribute:: __repository_version__
      :annotation: = 0.0.1

      

   .. method:: open_connection(self, *args, **kwargs)
      :abstractmethod:



   .. method:: close_connection(self, *args, **kwargs)
      :abstractmethod:



   .. method:: create_table(self, table: str, *args, **kwargs)
      :abstractmethod:


      Create a table in the repository  (a container to hold elements of the same type)

      :param table: Name of the table to be created
      :type table: str
      :param args: Additional arguments to be used
      :param kwargs: Additional keyword arguments to be used
      :return: None


   .. method:: retrieve_tables(self)
      :abstractmethod:


      Retrieve tables from the repository.

      :return: List with the table names
      :rtype: List[str]


   .. method:: exists_table(self, table: str, *args, **kwargs)
      :abstractmethod:


      Check if a table exists in the repsitory

      :param table: Name of the table to be checked
      :type table: str
      :param args: Additional arguments to be used
      :param kwargs: Additional keyword arguments to be used
      :return: True if table exists and False otherwise
      :rtype: bool


   .. method:: drop_tables(self, tables: List[str], *args, **kwargs)
      :abstractmethod:


      Delete tables from the repository

      :param tables: Name of the tables to delete
      :type tables: List[str]
      :param args: Additional arguments to be used
      :param kwargs: Additional keyword arguments to be used
      :return: None


   .. method:: create_element(self, table: str, obj: AbstractEntry, *args, **kwargs)
      :abstractmethod:


      Insert a new element in the table

      :param table: Name of the table to create the entry
      :type table: str
      :param obj: Entry to be inserted, class derived from ``AbstractEntry``
      :type obj: AbstractEntry
      :param args: Additional arguments to be used
      :param kwargs: Additional keyword arguments to be used
      :return: None


   .. method:: retrieve_elements(self, table: str, cast_to: type, **where)
      :abstractmethod:


      Retrieve elements from a table in the database, basing on a simle keyworded query

      :param table: Name of the table to retrieve the elements
      :type table: str
      :param cast_to: Type to cast the elements after retrieval from the database (Derived from ``AbstractEntry`)
      :type cast_to: type
      :param where: Keyworded clauses which specify conditions, the key is he field name (from the entry) and value is the data associated.
          Elements that match the conditions will be retrieved (e.g. person_id='person1')
      :type where: Dict[str,Any]
      :return: List of the elements that matches the creteria
      :rtype: List[Any]


   .. method:: update_element(self, table: str, obj: AbstractEntry, **where)
      :abstractmethod:


      Update an element from the database table with another one, matching a criteria

      :param table: Name of the table do modify the element
      :type table: str
      :param obj: New element to be inserted (Derived from ``AbstractEntry`)
      :type obj: AbstractEntry
      :param where: Keyworded clauses which specify conditions, the key is he field name (from the entry) and value is the data associated.
          Elements that match the conditions will be retrieved (e.g. person_id='person1')
      :type where: Dict[str,Any]
      :return: None


   .. method:: drop_elements(self, table: str, **where)
      :abstractmethod:


      Delete elements from a database table that matches a criteria

      :param table: Name of the table that elements will be deleted
      :type table: str
      :param where:
      :param where: Keyworded clauses which specify conditions, the key is he field name (from the entry) and value is the data associated.
          Elements that match the conditions will be retrieved (e.g. person_id='person1')
      :type where: Dict[str,Any]
      :return: None



.. py:class:: RepositoryFactory

   .. method:: get_repository(repository: str, repository_type: str = Defaults.REPOSITORY_TYPE, storage_type: str = None, create_new: bool = True)
      :staticmethod:


      Get a repository, based on a implementation of the ``AbstractRepository`` class.

      :param repository: Name of the repository to get
      :type repository: str
      :param repository_type: Repository implementation type (default is ``tinydb`` repository imlpementation)
      :type repository_type: str
      :param storage_type: Type of the storage (default is json)
      :type storage_type: str
      :param create_new: True to create a new repository (overwriting an existent one), false otherwise (default is True)
      :type create_new: bool
      :return: The repository in the specified implementation (derived from ``AbstractRepository``)
      :rtype: AbstractRepository
      :raises ValueError: If the repository implementation type is invalid


   .. method:: exists_repository(repository: str, repository_type=Defaults.REPOSITORY_TYPE)
      :staticmethod:


      Check if a repository already exists

      :param repository: Name of the repository
      :type repository: str
      :param repository_type: Repository implementation type (default is ``tinydb`` repository imlpementation)
      :type repository_type: str
      :return: True of the repository already exists and false otherwise
      :rtype: bool
      :raises ValueError: If the repository implementation type is invalid



.. function:: check_and_create_table(repository: AbstractRepository, table_name: str, exists: str) -> bool

   Check if table exists and creates table based on `exists` variable policy. The table is always created if it does not exists

   :param repository: Repository that the table will be created
   :type repository: AbstractRepository
   :param table_name: Name of the table to be created
   :type table_name: str
   :param exists: Policy taken when the table already exists. This parameter can be:
       'pass' (default): will do nothing
       'fail': will raise `TableAlreadyExists` exception
       'overwrite': will drop the old table and create a new table
   :return: True indicating if the a new table was created, False otherwise
   :rtype: bool
   :raises:
   TableAlreadyExists
       If table already exists and 'fail' parameter is passed
   ValueError
       If exists parameter is invalid


.. function:: get_repository_connection(repository: AbstractRepository, *args, **kwargs)


.. function:: generic_read_entry(info_type: type, repository: AbstractRepository, table: str, **where) -> list

   Helper method to read an entry from a repository

   :param info_type: Type of the entry that will be read. The type of the element must derive from AbstractDescriptorEntry
   :type info_type: AbstractEntry
   :param repository: Repository object used to read the element from
   :type repository: AbstractRepository
   :param table: Table of the repository where the element will be retrieved
   :type table: str
   :param where: The clauses to be matched when searching an entry
   :type where: Dict[Any, Any]
   :return: List of elements matching the criteria passed. The elements are all converted to `info_type` argument type
   :rtype: list


.. function:: generic_write_entry(info: AbstractEntry, repository: AbstractRepository, table: str, create: bool = False, **where)

   Helper method to write an entry in a repository

   :param info: Information to be written in repository (derived from AbstractDescriptorEntry class)
   :type info: AbstractEntry
   :param repository: Repository object used to write the element to
   :type repository: AbstractRepository
   :param table: Table of the repository where the element will be created/updated
   :type table: str
   :param create: If true it will create a element in the repository and if false, it will update. If the repository implementation supports insertion upon update, the element will be created when updating, else an exception will be raised
   :type create: bool
   :param where: The clauses to be matched when updating an entry
   :type where: Dict[Any, Any]


.. data:: log
   

   

.. function:: path_extend(*args) -> str


.. py:class:: ClusterDefaults

   .. attribute:: CLUSTER_REPOSITORY_DIR
      

      

   .. attribute:: CLUSTER_SEARCH_PATH
      

      

   .. attribute:: CLUSTER_DEFAULT_FLETYPES
      :annotation: = ['yaml', 'yml']

      


.. py:class:: ClusterControlData(**kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`


.. py:class:: ClusterData(**kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`


.. py:class:: ClusterRepositoryOperations(repository_name: str = 'cluster.json', repository_type: str = Defaults.REPOSITORY_TYPE, cluster_prefix='cluster')

   .. method:: exists_platform_db(self)



   .. method:: create_repository(self, exists: str = 'pass')



   .. method:: new_cluster(self, cluster_name, cluster_config, state: str = 'running')



   .. method:: get_cluster(self, cluster_id: str)



   .. method:: get_all_clusters(self)



   .. method:: update_cluster(self, cluster_data: ClusterData)



   .. method:: remove_cluster(self, cluster_id)




.. py:class:: ClusterDefaults

   .. attribute:: CLUSTER_REPOSITORY_DIR
      

      

   .. attribute:: CLUSTER_SEARCH_PATH
      

      

   .. attribute:: CLUSTER_DEFAULT_FLETYPES
      :annotation: = ['yaml', 'yml']

      


.. data:: __module_name__
   :annotation: = cluster

   

.. data:: __module_description__
   :annotation: = Create and manages compute clusters

   

.. data:: __module_dependencies__
   :annotation: = ['node', 'tag', 'group', 'template']

   

