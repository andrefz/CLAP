:mod:`clap.modules.spits`
=========================

.. py:module:: clap.modules.spits


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   module/index.rst
   repository/index.rst


Package Contents
----------------

.. py:class:: Defaults

   .. attribute:: log_level
      

      

   .. attribute:: app_name
      :annotation: = clap

      

   .. attribute:: private_path
      

      

   .. attribute:: storage_path
      

      

   .. attribute:: elasticluster_storage_path
      

      

   .. attribute:: drivers_path
      

      

   .. attribute:: modules_path
      

      

   .. attribute:: share_playbooks
      

      

   .. attribute:: templates_path
      

      


.. py:class:: PlatformFactory

   .. attribute:: __multi_instance_api__
      

      

   .. attribute:: __module_iface__
      

      

   .. method:: get_module_interface()
      :staticmethod:


      Get the default ModuleInterface used to pick clap modules

      :return: The modules interface
      :rtype: ModuleInterface


   .. method:: get_instance_api()
      :staticmethod:


      Get the default MultiInstance API used to manipulate cluster, nodes and modules across different drivers

      :return: The MultiInstanceAPI object to manipulate cluster, nodes and modules
      :rtype: MultiInstanceAPI



.. py:class:: MultiInstanceAPI(platform_db: str, repository_type: str, default_driver: str)

   API used to manage and perform operations in cluster and nodes from different driver implementations,
   and cloud providers in a transparently manner.

   .. attribute:: __drivers_map__
      

      

   .. attribute:: __interfaces_map__
      

      

   .. method:: __find_ifaces()
      :staticmethod:



   .. method:: _get_instance_iface(self, driver_id: str = None)



   .. method:: create_cluster(self, cluster_template_path: str, driver_id: str = None, *args, **kwargs)



   .. method:: stop_cluster(self, cluster_id: str, *args, **kwargs)



   .. method:: start_nodes(self, cluster_id: str, *args, **kwargs)



   .. method:: stop_nodes(self, node_ids: List[str], *args, **kwargs)



   .. method:: check_nodes_alive(self, node_ids: List[str], *args, **kwargs)



   .. method:: execute_playbook_in_nodes(self, node_ids: List[str], playbook_path: str, *args, **kwargs)



   .. method:: get_connection_to_nodes(self, node_ids: List[str], *args, **kwargs)



   .. method:: get_cluster(self, cluster_id: str)



   .. method:: get_clusters(self, cluster_ids: List[str] = None)



   .. method:: get_clusters_by_tag(self, **tags)



   .. method:: get_node(self, node_id: str)



   .. method:: get_nodes(self, node_ids: List[str] = None)



   .. method:: get_nodes_from_cluster(self, cluster_id: str)




.. data:: log
   

   

.. py:class:: SpitsProcessInfo(*args, **kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`

   .. attribute:: SPITS_JM
      :annotation: = jobmanager

      

   .. attribute:: SPITS_TM
      :annotation: = taskmanager

      

   .. method:: __repr__(self)




.. py:class:: SpitsRepositoryOperations(repository_name: str)

   .. method:: create_repository(self)



   .. method:: update_control_info(self, control_info: SpitsControlInfo)



   .. method:: get_control_info(self)



   .. method:: register_installed(self, node_ids: List[str])



   .. method:: check_installed(self, node_ids: List[str])



   .. method:: deregister_installation(self, node_ids: List[str])



   .. method:: save_or_update_job(self, spits_job: SpitsJobInfo)



   .. method:: get_jobs(self, job_ids: List[str] = None)



   .. method:: get_job(self, job_id: str)



   .. method:: remove_job(self, job_id: str)



   .. method:: save_or_update_process(self, process_info: SpitsProcessInfo)



   .. method:: get_processes(self, process_ids: List[str] = None)



   .. method:: get_processes_by_job(self, job_ids: List[str])



   .. method:: get_process(self, process_id: str)



   .. method:: remove_process(self, process_id: str)




.. py:class:: SpitsJobInfo(*args, **kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`

   .. method:: __repr__(self)




.. data:: repository_name
   

   

.. data:: connection_timeout
   :annotation: = 30

   

.. data:: handshake_timeout
   :annotation: = 15

   

.. function:: __validate_playbook(playbook_path: str) -> str


.. function:: __register_installation(node_ids: List[str])


.. function:: __check_installed(node_ids: List[str])


.. function:: __deregister_installation(node_ids: List[str])


.. function:: spits_install(node_ids: List[str], spits_src: str)


.. function:: spits_check(node_ids: List[str])


.. function:: spits_uninstall(node_ids: List[str], *args, **kwargs)


.. function:: __perform_job_handshake(process: SpitsProcessInfo) -> SimpleEndpoint

   Create a new Endpoint to the connect to process and perform the handshake with jobid and start communication

   :return: A SimpleEndpoint to connect to the process
   :rtype: SimpleEndpoint


.. function:: __query_job_status(job_id: str, remote_exec_path: str, ssh: SSHClient)

   Query the status of a running job in a node. The status runs the spits-job-status and cat the resulting string.

   :param job_id: ID of the job the perform the query
   :type job_id: str
   :param remote_exec_path: Path with spits scripts to run
   :type remote_exec_path: str
   :param ssh: Connected SSH Client with the node to execute commands
   :type ssh: SSHClient
   :return: The job status dictionary containing:
   - finished: 0 if job was not terminated 1 otherwise
   - nodes:
       - manager: 'jobmanager' or 'taskmanager'
       - type: 'node'
       - address: IP Address of the node
       - port: Port of the node
       - pid: PID of the process in node
   :rtype: dict


.. function:: __is_process_alive(process: SpitsProcessInfo) -> bool

   Establishes a connection to the process and send a heartbeat (to query if it is alive)

   :param process: Process to query information
   :type process: SpitsProcessInfo

   :return: True if heartbeat is successed (node is alive) false otherwise
   :rtype: bool


.. function:: __bind_process_ports(job: SpitsJobInfo, processes: List[SpitsProcessInfo], instance_api: MultiInstanceAPI)


.. function:: spits_job_create(job_id: str, job_conf_path: str, node_ids: List[str]) -> SpitsJobInfo


.. function:: spits_job_list(job_ids: List[str] = None) -> List[SpitsJobInfo]


.. function:: spits_job_status(job_id: str)


.. function:: spits_job_copy(job_id: str, dest: str)


.. function:: spits_job_stop(job_id: str)


.. function:: spits_process_start_jm(jobid: str, node_ids: List[str])


.. function:: spits_process_start_tm(jobid: str, node_ids: List[str])


.. function:: spits_process_terminate(process_id: str)

   Terminate the process

   :return: True on success, False otherwise
   :rtype: bool


.. function:: spits_process_list(process_ids=None) -> List[SpitsProcessInfo]


.. function:: spits_processes_alive(process_ids: List[str]) -> Dict[str, bool]


.. function:: spits_worker_list(process_id: str)

   Get the list of worker_list that the job manager is communicating

   :param process_id: ProcessID to query information
   :type process_id: str

   :return: Dictionary with the worker nodes
   :rtype: dict


.. function:: spits_worker_add(process_id: str, tm_process_ids: List[str])


.. function:: spits_worker_remove(process_id: str, tm_process_ids: List[str])


.. function:: spits_metrics_list(process_id: str)

   Query the list of metrics of the underlying process

   :param process_id: Id of the process to query information
   :type process_id: str

   :return: Dictionary with the metrics list
   :rtype: dict


.. function:: spits_metrics_values(process_id: str, metrics: List[str])


.. data:: name
   :annotation: = spits

   

.. data:: description
   :annotation: = Spits Module for manage Spits Jobs

   

.. data:: long_description
   :annotation: = Long SPITS module description

   

.. data:: version
   :annotation: = 0.1.0

   

.. data:: url
   :annotation: = 

   

.. data:: install_requires
   :annotation: = ['paramiko']

   

