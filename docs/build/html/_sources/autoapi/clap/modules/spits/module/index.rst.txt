:mod:`clap.modules.spits.module`
================================

.. py:module:: clap.modules.spits.module


Module Contents
---------------

.. data:: repository_name
   

   

.. data:: connection_timeout
   :annotation: = 30

   

.. data:: handshake_timeout
   :annotation: = 15

   

.. function:: __validate_playbook(playbook_path: str) -> str


.. function:: __register_installation(node_ids: List[str])


.. function:: __check_installed(node_ids: List[str])


.. function:: __deregister_installation(node_ids: List[str])


.. function:: spits_install(node_ids: List[str], spits_src: str)


.. function:: spits_check(node_ids: List[str])


.. function:: spits_uninstall(node_ids: List[str], *args, **kwargs)


.. function:: __perform_job_handshake(process: SpitsProcessInfo) -> SimpleEndpoint

   Create a new Endpoint to the connect to process and perform the handshake with jobid and start communication

   :return: A SimpleEndpoint to connect to the process
   :rtype: SimpleEndpoint


.. function:: __query_job_status(job_id: str, remote_exec_path: str, ssh: SSHClient)

   Query the status of a running job in a node. The status runs the spits-job-status and cat the resulting string.

   :param job_id: ID of the job the perform the query
   :type job_id: str
   :param remote_exec_path: Path with spits scripts to run
   :type remote_exec_path: str
   :param ssh: Connected SSH Client with the node to execute commands
   :type ssh: SSHClient
   :return: The job status dictionary containing:
   - finished: 0 if job was not terminated 1 otherwise
   - nodes:
       - manager: 'jobmanager' or 'taskmanager'
       - type: 'node'
       - address: IP Address of the node
       - port: Port of the node
       - pid: PID of the process in node
   :rtype: dict


.. function:: __is_process_alive(process: SpitsProcessInfo) -> bool

   Establishes a connection to the process and send a heartbeat (to query if it is alive)

   :param process: Process to query information
   :type process: SpitsProcessInfo

   :return: True if heartbeat is successed (node is alive) false otherwise
   :rtype: bool


.. function:: __bind_process_ports(job: SpitsJobInfo, processes: List[SpitsProcessInfo], instance_api: MultiInstanceAPI)


.. function:: spits_job_create(job_id: str, job_conf_path: str, node_ids: List[str]) -> SpitsJobInfo


.. function:: spits_job_list(job_ids: List[str] = None) -> List[SpitsJobInfo]


.. function:: spits_job_status(job_id: str)


.. function:: spits_job_copy(job_id: str, dest: str)


.. function:: spits_job_stop(job_id: str)


.. function:: spits_process_start_jm(jobid: str, node_ids: List[str])


.. function:: spits_process_start_tm(jobid: str, node_ids: List[str])


.. function:: spits_process_terminate(process_id: str)

   Terminate the process

   :return: True on success, False otherwise
   :rtype: bool


.. function:: spits_process_list(process_ids=None) -> List[SpitsProcessInfo]


.. function:: spits_processes_alive(process_ids: List[str]) -> Dict[str, bool]


.. function:: spits_worker_list(process_id: str)

   Get the list of worker_list that the job manager is communicating

   :param process_id: ProcessID to query information
   :type process_id: str

   :return: Dictionary with the worker nodes
   :rtype: dict


.. function:: spits_worker_add(process_id: str, tm_process_ids: List[str])


.. function:: spits_worker_remove(process_id: str, tm_process_ids: List[str])


.. function:: spits_metrics_list(process_id: str)

   Query the list of metrics of the underlying process

   :param process_id: Id of the process to query information
   :type process_id: str

   :return: Dictionary with the metrics list
   :rtype: dict


.. function:: spits_metrics_values(process_id: str, metrics: List[str])


