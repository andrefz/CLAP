:mod:`clap.modules.node`
========================

.. py:module:: clap.modules.node


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   commands/index.rst
   interactive/index.rst
   module/index.rst


Package Contents
----------------


.. py:class:: PlatformFactory

   .. attribute:: __multi_instance_api__
      

      

   .. attribute:: __module_iface__
      

      

   .. method:: get_module_interface()
      :staticmethod:


      Get the default ModuleInterface used to pick clap modules

      :return: The modules interface
      :rtype: ModuleInterface


   .. method:: get_instance_api(platform_db: str = Defaults.PLATFORM_REPOSITORY, repository_type: str = Defaults.REPOSITORY_TYPE, default_driver: str = Defaults.DRIVER_ID)
      :staticmethod:


      Get the default MultiInstance API used to manipulate cluster, nodes and modules across different drivers

      :return: The MultiInstanceAPI object to manipulate cluster, nodes and modules
      :rtype: MultiInstanceAPI



.. py:class:: AbstractParser

   .. method:: add_parser(self, commands_parser: argparse._SubParsersAction)
      :abstractmethod:




.. data:: log
   

   

.. function:: interactive_shell(chan)


.. function:: start_nodes(node_ids: Dict[str, int]) -> List[NodeInfo]


.. function:: list_nodes(node_ids: List[str] = None, tags: Dict[str, str] = None) -> List[NodeInfo]


.. function:: is_alive(node_ids: List[str], tags: Dict[str, str] = None) -> Dict[str, bool]


.. function:: stop_nodes(node_ids: List[str], tags: Dict[str, str] = None) -> List[str]


.. function:: connect_to_node(node_id: str)


.. function:: resume_nodes(node_ids: List[str], tags: Dict[str, str] = None) -> List[str]


.. function:: pause_nodes(node_ids: List[str], tags: Dict[str, str] = None) -> List[str]


.. function:: execute_playbook(playbook_file: str, node_ids: List[str], tags: Dict[str, str] = None, extra_args: Dict[str, str] = None) -> Dict[str, bool]


.. function:: get_ssh_connections(node_ids: List[str], tags: Dict[str, str] = None, *args, **kwargs) -> Dict[str, SSHClient]


.. py:class:: NodeParser

   Bases: :class:`clap.common.module.AbstractParser`

   .. method:: add_parser(self, commands_parser: argparse._SubParsersAction)



   .. method:: command_node_start(self, namespace: argparse.Namespace)



   .. method:: command_node_list(self, namespace: argparse.Namespace)



   .. method:: command_node_show(self, namespace: argparse.Namespace)



   .. method:: command_node_alive(self, namespace: argparse.Namespace)



   .. method:: command_node_stop(self, namespace: argparse.Namespace)



   .. method:: command_node_resume(self, namespace: argparse.Namespace)



   .. method:: command_node_pause(self, namespace: argparse.Namespace)



   .. method:: command_node_playbook(self, namespace: argparse.Namespace)



   .. method:: command_node_exec_command(self, namespace: argparse.Namespace)



   .. method:: command_node_connect(self, namespace: argparse.Namespace)




.. function:: interactive_shell(chan)


.. py:class:: PlatformFactory

   .. attribute:: __multi_instance_api__
      

      

   .. attribute:: __module_iface__
      

      

   .. method:: get_module_interface()
      :staticmethod:


      Get the default ModuleInterface used to pick clap modules

      :return: The modules interface
      :rtype: ModuleInterface


   .. method:: get_instance_api(platform_db: str = Defaults.PLATFORM_REPOSITORY, repository_type: str = Defaults.REPOSITORY_TYPE, default_driver: str = Defaults.DRIVER_ID)
      :staticmethod:


      Get the default MultiInstance API used to manipulate cluster, nodes and modules across different drivers

      :return: The MultiInstanceAPI object to manipulate cluster, nodes and modules
      :rtype: MultiInstanceAPI



.. py:class:: NodeInfo(**kwargs)

   Bases: :class:`clap.common.repository.AbstractEntry`

   This class holds information about a node that is stored in the repository and used by several interfaces
   Each node is unique and is composed by the following elements:
       * node_id: The unique identification of the node, used to perform operations across modules and instance interfaces
       * node_name: The name of the node used by the driver object that controls it
       * cluster_id: ID of the cluster that this node is attached to
       * flavor: Instance flavor (e.g., t2.micro in aws)
       * status: Last known status of the node (see PlatformCodes)
       * ip: IP address used to connect to this node (address used to perform SSH)
       * driver_id: ID of the driver that controls this node
       * driver_version: Version of the driver used by this node
       * keypair: The name of the keypair used to connect to the machines created in the node cluster
       * key: The private key file used to perform SSH and connect to machines
       * tags: Additional user tags for node identification

   .. method:: __repr__(self)




.. function:: start_nodes(node_ids: Dict[str, int]) -> List[NodeInfo]


.. function:: list_nodes(node_ids: List[str] = None, tags: Dict[str, str] = None) -> List[NodeInfo]


.. function:: is_alive(node_ids: List[str], tags: Dict[str, str] = None) -> Dict[str, bool]


.. function:: stop_nodes(node_ids: List[str], tags: Dict[str, str] = None) -> List[str]


.. function:: resume_nodes(node_ids: List[str], tags: Dict[str, str] = None) -> List[str]


.. function:: pause_nodes(node_ids: List[str], tags: Dict[str, str] = None) -> List[str]


.. function:: execute_playbook(playbook_file: str, node_ids: List[str], tags: Dict[str, str] = None, extra_args: Dict[str, str] = None) -> Dict[str, bool]


.. function:: get_ssh_connections(node_ids: List[str], tags: Dict[str, str] = None, *args, **kwargs) -> Dict[str, SSHClient]


.. function:: connect_to_node(node_id: str)


.. data:: __module_name__
   :annotation: = node

   

.. data:: __module_description__
   :annotation: = Manage and perform operation with compute nodes

   

.. data:: __module_dependencies__
   :annotation: = ['tag', 'group']

   

